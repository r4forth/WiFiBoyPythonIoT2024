# 23. 紅外線傳送與接收

##  紅外線遙控器的工作原理

紅外線遙控器是利用紅外線光（波長在 700 nm 到 1 mm 之間的電磁波）來傳輸數據的控制設備，常用於電視、空調等家電的遠端控制。

1. 數據編碼與重製

當你按下遙控器上的按鍵時，遙控器會將該按鍵對應的數據轉換為二進制數據（0 和 1 的組合）。

二進制數據接著會被編碼，常見的編碼方式有：

脈衝位置調製（PPM）：透過改變脈衝之間的時間間隔來傳遞數據。
脈衝寬度調製（PWM）：透過改變脈衝的寬度來表示二進制數據。
曼徹斯特編碼：透過脈衝的上升和下降邊緣來表示二進制數據。
編碼後的二進制數據會調製在一個特定的載波頻率上，最常見的是 38kHz。

1. 紅外線發射
調製後的信號會控制紅外線 LED 發光二極體，使其在 38kHz 的頻率下快速閃爍，從而發射紅外線光信號。
這些紅外線光束無法穿透牆壁，因此遙控器通常需要在接收裝置的視線範圍內才能有效工作。
1. 紅外線接收
接收端通常包含一個紅外線接收器，它可以檢測和解調來自遙控器的 38kHz 調製信號。
當接收到紅外線信號後，接收器會將信號解調，將其中的載波去除，還原成最初的二進制數據。
然後接收器將解碼後的二進制數據傳送給控制電路，根據數據內容執行相應的動作（如調整音量、切換頻道等）。
1. 應用實例
家用電器控制：紅外線遙控器最常見的應用就是在電視、音響、空調等家電的遠端控制上。遙控器透過發送不同的紅外線信號來執行各種功能，如開關機、調整音量、選擇頻道等。
機頂盒：紅外線遙控器可以用來操作數位機頂盒，進行頻道切換和節目錄製。
智能家居：部分智能家居設備可以通過紅外線遙控器來控制燈光、窗簾和其他設備的開關。
1. 常見標準與協議
NEC 協議：一種非常普及的紅外線遙控器通訊協議，由日本電氣公司（NEC）開發。它的特點是信號結構清晰，使用簡單。
RC5 協議：由飛利浦公司開發的紅外線遙控器協議，使用曼徹斯特編碼方式，並具有很強的抗干擾能力。
1. 限制與考量
視線要求：紅外線無法穿透障礙物，因此遙控器和接收設備之間需要保持直接的視線。
干擾問題：其他紅外線源（如陽光或其他遙控器）可能會干擾信號的接收，導致控制失靈。
這就是紅外線遙控器的基本工作原理與應用。你有興趣深入了解某些特定部分嗎？

HW-477 是市面上常見的紅外線接收模組，一個大約台幣30元左右。

![](/img/23/Python23_00.png)

我們可以用底下的接線方式與 WiFiBoy 玩學機相連。

* VCC    -- USB(WBIO 1)
* GND    -- GND(WBIO 2)
* DATA   -- IO2(WBIO 4)

![](/img/23/Python23_01.png)


## 如何判斷你手邊的遙控器是否能用?

你是否有遇過這樣的情況?抽屜裡一堆遙控器，不知道是否可以用?有時可能連當初搭配的機器都丟了，遙控器還在。這些閒置的遙控器是否能拿來再利用?

![](/img/23/Python23_02.png)

在過去，我們可能需要買這樣的多功能三用電表來解紅外線的編碼。

![](/img/23/Python23_03.png)

不過現在有了 WiFiBoy 玩學機，您只要額外買一個 HW-477 模組，就能做到同樣的功能。

### 讀取紅外線遙控器的按鍵編碼

我們會利用 MicroPython 社群理這個功能強大的函式庫。

* [Device drivers for IR (infra red) remote controls](https://github.com/peterhinch/micropython_ir)

![](/img/23/Python23_04.png)

我們只要使用接收的驅動程式即可，就能解讀大部份遙控器的控制訊號。一般來說很多遙控器都是使用 NEC 編碼。您只要下載專案，將 **ir_rx/nec.py** 上傳到玩學機的 **lib* 目錄下即可，就能跟著我們來是別遙控器上每個按鍵的編碼。

![](/img/23/Python23_05.png)


### 先判讀每個按鍵的編碼

```
from ir_rx.nec import NEC_16
from machine import Timer
from machine import Pin

def callBack(data, addr, ctrl):
    global _data, _addr
    _data = ir_key[data]
    _addr = addr
    if data > 0:
        print("data: {:02x} addr: {:04x}".format(data, addr))
        print(_data)

ir = NEC_16(Pin(2, Pin.IN), callBack)
```


## 用遙控器操作玩學機做事

取得每個按鍵的編碼值後，您就可以建一個對照表，透過對照表的關鍵字，像是 **Power**、**Mute** 等，再去對照玩學機中可以執行的函數或程式，這樣就可以變成一個很實用的工具。

```
from ir_rx.nec import NEC_16
from machine import Pin
import time

def callBack(data, addr, ctrl):
    global _data, _addr
    _data = ir_key.get(data, "Unknown")
    _addr = addr
    if data > 0:
        print("data: {:02x} addr: {:04x}".format(data, addr))
        print(_data)

ir_key = {
    0x12 : 'Power',
    0x1a : 'Mute',
    0x1e : 'Favorite',
    0x01 : '1',
    0x02 : '2',
    0x03 : '3',
    0x04 : '4',
    0x05 : '5',
    0x06 : '6',
    0x07 : '7',
    0x08 : '8',
    0x09 : '9',
    0x1b : '0',
    0x0a : 'Vol_up',
    0x0c : 'Vol_down',
    0x1f : 'CH_up',
    0x0e : 'CH_down',
    0x0d : 'Full Screen'   
}

_data = None
ir = NEC_16(Pin(2, Pin.IN), callBack)

while True:
    if _data == 'Power':
        print("Action 1 Triggered")
        wb.cls()
    elif _data == '2':
        print("Action 2 Triggered")
        wb.str('Press 2!', 20, 30, 4)
    time.sleep(0.1)
```

###  callBack 函數功能說明

* callBack 是接收到紅外線信號後執行的函數，會在接收到每個紅外線信號後被自動調用。
* data: 傳遞的遙控器按鍵值。
* addr: 傳遞的裝置地址。
* ctrl: 用於控制特定行為的附加資訊（通常在 NEC 協議中不使用）。
* global _data, _addr 將 _data 和 _addr 宣告為全局變數，以便在 while 迴圈中可以訪問它們。
* _data = ir_key.get(data, "Unknown"): 使用 ir_key 字典將 data 轉換為對應的按鍵名稱。如果 data 未在字典中，則回傳 "Unknown"。
*print("data: {:02x} addr: {:04x}".format(data, addr)): 以十六進位顯示接收到的 data 和 addr，方便除錯和觀察。
* 如果 data > 0，則印出 _data 的內容。

### 當收到訊號呼叫信號處理函數

```
ir = NEC_16(Pin(2, Pin.IN), callBack)
```

創建了一個 NEC_16 類的實例 ir，並且將 GPIO 2 設定為紅外線接收引腳。
每當接收到信號時，會調用之前定義的 callBack 函數來處理信號。


## 參考資料

1. [樹莓派與紅外線遙控器](https://s761111.gitbook.io/raspi-sensor/shu-mei-pai-yu-gong-wai-xian)
2. [使用網路與搖桿、手機控制](https://s761111.gitbook.io/raspi-sensor/shu-mei-pai-yu-zi-zou-che/shi-yong-wang-lu-yu-yao-gan-kong-zhi)